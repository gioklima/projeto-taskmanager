## disponibilizaÃ§Ã£o do cÃ³digo

#!/usr/bin/env python3
import json
import os
from datetime import datetime
from typing import List, Dict, Any, Optional

TASKS_FILE = "tasks.json"


class Task:
    """Representa uma tarefa com tÃ­tulo, descriÃ§Ã£o, prioridade e status."""

    def __init__(
        self,
        id: int,
        title: str,
        description: str = "",
        priority: str = "mÃ©dia",
        created_at: Optional[str] = None,
        done: bool = False,
    ):
        self.id = id
        self.title = title.strip()
        self.description = description.strip()
        self.priority = priority.lower() if priority.lower() in ("alta", "mÃ©dia", "baixa") else "mÃ©dia"
        self.created_at = created_at or datetime.now().isoformat()
        self.done = done

    def to_dict(self) -> Dict[str, Any]:
        """Converte o objeto em dicionÃ¡rio serializÃ¡vel."""
        return vars(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Task":
        """Cria uma instÃ¢ncia de Task a partir de um dicionÃ¡rio."""
        return cls(**data)


# ------------------ PersistÃªncia ------------------

def load_tasks() -> List[Task]:
    """Carrega tarefas do arquivo JSON."""
    if not os.path.exists(TASKS_FILE):
        return []
    try:
        with open(TASKS_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        return [Task.from_dict(t) for t in data]
    except (json.JSONDecodeError, IOError) as e:
        print(f"Erro ao carregar tarefas: {e}")
        return []


def save_tasks(tasks: List[Task]) -> None:
    """Salva as tarefas em arquivo JSON."""
    try:
        with open(TASKS_FILE, "w", encoding="utf-8") as f:
            json.dump([t.to_dict() for t in tasks], f, indent=2, ensure_ascii=False)
    except IOError as e:
        print(f"Erro ao salvar tarefas: {e}")


# ------------------ OperaÃ§Ãµes ------------------

def next_id(tasks: List[Task]) -> int:
    """Gera o prÃ³ximo ID disponÃ­vel."""
    return max((t.id for t in tasks), default=0) + 1


def add_task(tasks: List[Task]) -> None:
    """Adiciona uma nova tarefa."""
    title = input("TÃ­tulo: ").strip()
    if not title:
        print("âŒ TÃ­tulo nÃ£o pode ser vazio.")
        return

    description = input("DescriÃ§Ã£o (opcional): ").strip()
    priority = input("Prioridade (alta/mÃ©dia/baixa) [mÃ©dia]: ").strip().lower() or "mÃ©dia"

    new_task = Task(next_id(tasks), title, description, priority)
    tasks.append(new_task)
    print(f"âœ… Tarefa '{new_task.title}' adicionada com ID {new_task.id}.")


def list_tasks(tasks: List[Task], filter_by: Optional[str] = None) -> None:
    """Lista as tarefas, com opÃ§Ã£o de filtrar por status."""
    filtered = [
        t for t in tasks
        if not filter_by
        or (filter_by == "pendentes" and not t.done)
        or (filter_by == "concluidas" and t.done)
    ]

    if not filtered:
        print("Nenhuma tarefa encontrada.")
        return

    print("\n=== Lista de Tarefas ===")
    for t in filtered:
        done_flag = "âœ…" if t.done else "â¬œ"
        print(f"{done_flag} [{t.id}] {t.title} ({t.priority}) - {t.description}")
    print()


def mark_done(tasks: List[Task], tid: int) -> None:
    """Marca uma tarefa como concluÃ­da."""
    task = next((t for t in tasks if t.id == tid), None)
    if not task:
        print("âŒ ID nÃ£o encontrado.")
        return
    if task.done:
        print("âš ï¸  Tarefa jÃ¡ estÃ¡ concluÃ­da.")
        return
    task.done = True
    print(f"âœ… Tarefa {tid} marcada como concluÃ­da.")


def delete_task(tasks: List[Task], tid: int) -> None:
    """Exclui uma tarefa pelo ID."""
    for i, t in enumerate(tasks):
        if t.id == tid:
            tasks.pop(i)
            print(f"ğŸ—‘ï¸  Tarefa {tid} excluÃ­da.")
            return
    print("âŒ ID nÃ£o encontrado.")


def stats(tasks: List[Task]) -> None:
    """Mostra estatÃ­sticas gerais das tarefas."""
    total = len(tasks)
    done = sum(t.done for t in tasks)
    pending = total - done
    print(f"ğŸ“Š Total: {total} | âœ… ConcluÃ­das: {done} | â¬œ Pendentes: {pending}")


def help_text() -> None:
    """Mostra os comandos disponÃ­veis."""
    print("""
Comandos disponÃ­veis:
 add               - adicionar nova tarefa
 list              - listar todas
 list pend         - listar pendentes
 list done         - listar concluÃ­das
 done <id>         - marcar como concluÃ­da
 delete <id>       - excluir tarefa
 save              - salvar em tasks.json
 load              - recarregar tasks.json
 stats             - ver estatÃ­sticas
 help              - mostrar ajuda
 exit              - sair
""")


# ------------------ CLI ------------------

def main() -> None:
    tasks = load_tasks()
    print("ğŸ“ Gerenciador de Tarefas CLI")
    help_text()

    while True:
        try:
            cmd = input("> ").strip().split()
        except (EOFError, KeyboardInterrupt):
            print("\nğŸ‘‹ Saindo...")
            break

        if not cmd:
            continue

        command, *args = cmd
        if command == "add":
            add_task(tasks)
        elif command == "list":
            if args and args[0] in ("pend", "pendentes"):
                list_tasks(tasks, "pendentes")
            elif args and args[0] in ("done", "concluidas"):
                list_tasks(tasks, "concluidas")
            else:
                list_tasks(tasks)
        elif command == "done" and args and args[0].isdigit():
            mark_done(tasks, int(args[0]))
        elif command == "delete" and args and args[0].isdigit():
            delete_task(tasks, int(args[0]))
        elif command == "save":
            save_tasks(tasks)
            print("ğŸ’¾ Tarefas salvas em tasks.json.")
        elif command == "load":
            tasks = load_tasks()
            print("ğŸ“‚ Tarefas recarregadas.")
        elif command == "stats":
            stats(tasks)
        elif command == "help":
            help_text()
        elif command in ("exit", "quit"):
            print("ğŸ‘‹ Saindo...")
            break
        else:
            print("â“ Comando desconhecido. Digite 'help' para ajuda.")


if __name__ == "__main__":
    main()

