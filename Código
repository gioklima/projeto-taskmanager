## disponibilização do código

#!/usr/bin/env python3
import json
import os
from datetime import datetime
from typing import List, Dict, Any, Optional

TASKS_FILE = "tasks.json"


class Task:
    """Representa uma tarefa com título, descrição, prioridade e status."""

    def __init__(
        self,
        id: int,
        title: str,
        description: str = "",
        priority: str = "média",
        created_at: Optional[str] = None,
        done: bool = False,
    ):
        self.id = id
        self.title = title.strip()
        self.description = description.strip()
        self.priority = priority.lower() if priority.lower() in ("alta", "média", "baixa") else "média"
        self.created_at = created_at or datetime.now().isoformat()
        self.done = done

    def to_dict(self) -> Dict[str, Any]:
        """Converte o objeto em dicionário serializável."""
        return vars(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Task":
        """Cria uma instância de Task a partir de um dicionário."""
        return cls(**data)


# ------------------ Persistência ------------------

def load_tasks() -> List[Task]:
    """Carrega tarefas do arquivo JSON."""
    if not os.path.exists(TASKS_FILE):
        return []
    try:
        with open(TASKS_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        return [Task.from_dict(t) for t in data]
    except (json.JSONDecodeError, IOError) as e:
        print(f"Erro ao carregar tarefas: {e}")
        return []


def save_tasks(tasks: List[Task]) -> None:
    """Salva as tarefas em arquivo JSON."""
    try:
        with open(TASKS_FILE, "w", encoding="utf-8") as f:
            json.dump([t.to_dict() for t in tasks], f, indent=2, ensure_ascii=False)
    except IOError as e:
        print(f"Erro ao salvar tarefas: {e}")


# ------------------ Operações ------------------

def next_id(tasks: List[Task]) -> int:
    """Gera o próximo ID disponível."""
    return max((t.id for t in tasks), default=0) + 1


def add_task(tasks: List[Task]) -> None:
    """Adiciona uma nova tarefa."""
    title = input("Título: ").strip()
    if not title:
        print("❌ Título não pode ser vazio.")
        return

    description = input("Descrição (opcional): ").strip()
    priority = input("Prioridade (alta/média/baixa) [média]: ").strip().lower() or "média"

    new_task = Task(next_id(tasks), title, description, priority)
    tasks.append(new_task)
    print(f"✅ Tarefa '{new_task.title}' adicionada com ID {new_task.id}.")


def list_tasks(tasks: List[Task], filter_by: Optional[str] = None) -> None:
    """Lista as tarefas, com opção de filtrar por status."""
    filtered = [
        t for t in tasks
        if not filter_by
        or (filter_by == "pendentes" and not t.done)
        or (filter_by == "concluidas" and t.done)
    ]

    if not filtered:
        print("Nenhuma tarefa encontrada.")
        return

    print("\n=== Lista de Tarefas ===")
    for t in filtered:
        done_flag = "✅" if t.done else "⬜"
        print(f"{done_flag} [{t.id}] {t.title} ({t.priority}) - {t.description}")
    print()


def mark_done(tasks: List[Task], tid: int) -> None:
    """Marca uma tarefa como concluída."""
    task = next((t for t in tasks if t.id == tid), None)
    if not task:
        print("❌ ID não encontrado.")
        return
    if task.done:
        print("⚠️  Tarefa já está concluída.")
        return
    task.done = True
    print(f"✅ Tarefa {tid} marcada como concluída.")


def delete_task(tasks: List[Task], tid: int) -> None:
    """Exclui uma tarefa pelo ID."""
    for i, t in enumerate(tasks):
        if t.id == tid:
            tasks.pop(i)
            print(f"🗑️  Tarefa {tid} excluída.")
            return
    print("❌ ID não encontrado.")


def stats(tasks: List[Task]) -> None:
    """Mostra estatísticas gerais das tarefas."""
    total = len(tasks)
    done = sum(t.done for t in tasks)
    pending = total - done
    print(f"📊 Total: {total} | ✅ Concluídas: {done} | ⬜ Pendentes: {pending}")


def help_text() -> None:
    """Mostra os comandos disponíveis."""
    print("""
Comandos disponíveis:
 add               - adicionar nova tarefa
 list              - listar todas
 list pend         - listar pendentes
 list done         - listar concluídas
 done <id>         - marcar como concluída
 delete <id>       - excluir tarefa
 save              - salvar em tasks.json
 load              - recarregar tasks.json
 stats             - ver estatísticas
 help              - mostrar ajuda
 exit              - sair
""")


# ------------------ CLI ------------------

def main() -> None:
    tasks = load_tasks()
    print("📝 Gerenciador de Tarefas CLI")
    help_text()

    while True:
        try:
            cmd = input("> ").strip().split()
        except (EOFError, KeyboardInterrupt):
            print("\n👋 Saindo...")
            break

        if not cmd:
            continue

        command, *args = cmd
        if command == "add":
            add_task(tasks)
        elif command == "list":
            if args and args[0] in ("pend", "pendentes"):
                list_tasks(tasks, "pendentes")
            elif args and args[0] in ("done", "concluidas"):
                list_tasks(tasks, "concluidas")
            else:
                list_tasks(tasks)
        elif command == "done" and args and args[0].isdigit():
            mark_done(tasks, int(args[0]))
        elif command == "delete" and args and args[0].isdigit():
            delete_task(tasks, int(args[0]))
        elif command == "save":
            save_tasks(tasks)
            print("💾 Tarefas salvas em tasks.json.")
        elif command == "load":
            tasks = load_tasks()
            print("📂 Tarefas recarregadas.")
        elif command == "stats":
            stats(tasks)
        elif command == "help":
            help_text()
        elif command in ("exit", "quit"):
            print("👋 Saindo...")
            break
        else:
            print("❓ Comando desconhecido. Digite 'help' para ajuda.")


if __name__ == "__main__":
    main()

